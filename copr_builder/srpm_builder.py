import glob
import logging
import os
import re
import tarfile

from . import GIT_URL_CONF, PACKAGE_CONF, PRE_ARCHIVE_CMD_CONF, ARCHIVE_CMD_CONF, GIT_BRANCH_CONF, \
    GIT_MERGE_BRANCH_CONF, CoprBuilderVersion
from .errors import SRPMBuilderError
from .git_repo import GitRepo
from .utils import run_command


log = logging.getLogger("copr.builder")


class SRPMBuilder(object):

    def __init__(self, project_data, git_dir=None):

        self.project_data = project_data

        self._spec_file = None
        self._archives = None

        if git_dir is None:
            self.git_repo = GitRepo(project_data[GIT_URL_CONF])
            self.git_repo.clone()
            self.git_dir = self.git_repo.gitdir
        else:
            os.chdir(git_dir)
            self.git_dir = git_dir
            self.git_repo = None

        self._log_prefix = 'Package %s:' % self.project_data[PACKAGE_CONF]

    @property
    def spec_file(self):
        if self._spec_file is None:
            self._spec_file = self._locate_spec_file()
        return self._spec_file

    @property
    def archives(self):
        ''' Return path to the created source archives

        To create archive look on self.make_archive.

        :returns: Archive paths or None if archives weren't created yet.
        :rtype: str or None
        '''
        return self._archives

    @property
    def spec_version(self):
        ''' Get version from spec file '''

        version = None
        release = None
        spec = self._locate_spec_file()

        with open(spec, 'r', encoding='utf-8') as f:
            for line in f:
                if line.startswith('Version:'):
                    version = line.split('Version:')[1].strip()
                elif line.startswith('Release:'):
                    release = line.split('Release:')[1].strip()

                if version and release:
                    break

        if not (version and release):
            raise SRPMBuilderError('Failed to extract version and release from spec file %s' % spec)

        release = release.split('%')[0]

        log.debug('%s Spec version: %s-%s', self._log_prefix, version, release)

        return CoprBuilderVersion(version, release, None, None)

    @spec_version.setter
    def spec_version(self, new_version):
        ''' Update version in spec file so the build number is always higher '''

        spec_file = self._locate_spec_file()

        new_spec = []

        with open(spec_file, 'r', encoding='utf-8') as f:
            for line in f:
                if line.startswith('Version:'):
                    new_spec.append('Version: %s\n' % new_version.version)
                elif line.startswith('Release:'):
                    new_spec.append('Release: %s.%sgit%s%%{?dist}\n' % (new_version.build,
                                                                        new_version.date,
                                                                        new_version.git_hash))
                else:
                    new_spec.append(line)

        with open(spec_file, 'w', encoding='utf-8') as f:
            for line in new_spec:
                f.write(line)

        log.debug('%s Spec version updated.', self._log_prefix)

    def prepare_build(self):
        # checkout to the right branch if needed
        if self.git_repo is None:
            raise SRPMBuilderError('Prepare build called but GitRepo is not set.')

        self.git_repo.checkout(self.project_data[GIT_BRANCH_CONF])

        # and do the merge if we want to
        if GIT_MERGE_BRANCH_CONF in self.project_data.keys():
            self.git_repo.merge(self.project_data[GIT_MERGE_BRANCH_CONF])

        self._run_prepare_archive_commands()

    def _run_prepare_archive_commands(self):
        '''Running commands to prepare archive process.

        This is especially useful when spec file is generated by some command.
        '''
        if PRE_ARCHIVE_CMD_CONF not in self.project_data:
            return

        log.debug('%s Running prepare archive commands.', self._log_prefix)

        command = str(self.project_data[PRE_ARCHIVE_CMD_CONF])
        ret, out = run_command(command, self.git_dir)
        if ret != 0:
            raise SRPMBuilderError('Failed to run prepare archive commands for %s:\n%s' % (self.project_data[PACKAGE_CONF], out))

    def make_archive(self):
        self._archives = self._make_archive()
        self._set_source(self._archives)

    def build(self):
        if self._archives is None:
            raise ValueError('You must create archive first!')
        srpm = self._make_srpm(self._archives)

        return srpm

    def _set_source(self, archive_names):
        spec_file = self._locate_spec_file()

        new_spec = []

        with open(spec_file, 'r', encoding='utf-8') as f:
            for line in f:
                if line.startswith('Source'):
                    m = re.search(r"Source([0-9]+):\s+(\S+)", line)
                    if not m or len(m.groups()) != 2:
                        raise SRPMBuilderError('Failed to parse Source line: %s' % line)

                    source_num = int(m.groups()[0])
                    source_name = m.groups()[1]

                    if source_name in os.listdir(self.git_dir):
                        # this source is already present in the git directory, we can just add it as is
                        new_spec.append('Source%d: %s\n' % (source_num, source_name))
                    else:
                        # try adding a next archive we generated in `make_archive`
                        try:
                            archive_name = archive_names.pop(0)
                        except IndexError:
                            # pylint: disable=raise-missing-from
                            raise SRPMBuilderError('Found Source%d in SPEC, but only %d sources generated.' % (source_num,
                                                                                                               len(archive_names)))
                        new_spec.append('Source%d: %s\n' % (source_num,
                                                            archive_name))
                else:
                    new_spec.append(line)

        with open(spec_file, 'w', encoding='utf-8') as f:
            for line in new_spec:
                f.write(line)

        log.debug('%s Spec source updated.', self._log_prefix)

    def _make_archive(self):
        ''' Create source archive for this project '''

        log.debug('%s Started creating source archive.', self._log_prefix)

        command = str(self.project_data[ARCHIVE_CMD_CONF])
        ret, out = run_command(command, self.git_dir)
        if ret != 0:
            raise SRPMBuilderError('Failed to create source archive for %s:\n%s' % (self.project_data[PACKAGE_CONF], out))

        # archive should be created, get everything that looks like one
        paths = [os.path.join(self.git_dir, f) for f in os.listdir(self.git_dir)]
        archives = [p for p in paths if (os.path.isfile(p) and tarfile.is_tarfile(p))]
        if not archives:
            raise SRPMBuilderError('Failed to find source archive after creating it.')

        log.debug('%s Created source archives: %s', self._log_prefix, archives)

        return archives

    def _make_srpm(self, archives):
        ''' Create SRPM using spec and source archive '''

        pkg_name = self.project_data[PACKAGE_CONF]

        # create 'packaging' directory in gitdir
        rpmdir = os.path.join(self.git_dir, 'packaging')
        if not os.path.exists(rpmdir):
            os.mkdir(rpmdir)

        # build the srpm
        data = {'srcdir': self.git_dir, 'rpmdir': rpmdir, 'spec': self.spec_file}
        command = 'rpmbuild -bs --define "_sourcedir {srcdir}" --define "_specdir {rpmdir}"' \
                  ' --define "_builddir {rpmdir}" --define "_srcrpmdir {rpmdir}"' \
                  ' --define "_rpmdir {rpmdir}" {spec}'.format(**data)
        ret, out = run_command(command, self.git_dir)

        # remove the source archives, we no longer need it
        for archive in archives:
            os.remove(os.path.join(self.git_dir, archive))

        if ret != 0:
            raise SRPMBuilderError('SPRM generation failed:\n %s' % out)

        srpm = None
        for line in out.split("\n"):
            # XXX: we assume there is only one line starting with "Wrote:"
            if line.startswith('Wrote:'):
                srpm = line.split('Wrote:')[1].strip()
                log.info('%s SRPM built for %s: %s', self._log_prefix, pkg_name, srpm)
                break

        if not srpm or not os.path.exists(srpm):
            raise SRPMBuilderError('Cannot find the generated SRPM "%s"' % srpm)

        return srpm

    def _glob_find(self, spec):
        # XXX: search in current directory and subdirectories
        res = glob.glob('%s/%s' % (self.git_dir, spec))
        res.extend(glob.glob('%s/*/%s' % (self.git_dir, spec)))

        return res

    def _locate_spec_file(self):
        ''' Try to find spec file for this project '''

        # look for spec files
        specs = self._glob_find('*.spec')

        # try to look for .spec.in files too (when extracting last version
        # before running autogen && configure)
        if not specs:
            specs = self._glob_find('*.spec.in')

        if not specs:
            raise SRPMBuilderError('Failed to find a spec file for %s.' % self.project_data[PACKAGE_CONF])
        if len(specs) > 1:
            raise SRPMBuilderError('Found more than one file that looks a spec file.')

        log.debug('%s Spec found: %s', self._log_prefix, specs[0])

        return specs[0]
